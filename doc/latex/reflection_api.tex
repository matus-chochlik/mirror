\documentclass[compress,table,xcolor=table]{beamer}
\input{beamer_mirror.tex}
\begin{document}
% ------------------------------------------------------------------------------
\title{Implementing a general-purpose reflection API}
% - Intro ----------------------------------------------------------------------
\section{Introduction}
\begin{frame}
  \frametitle{Intro}
  \framesubtitle{What is this? Why am I here? Who are these people?}
  \makebox[\linewidth][c]{
    \centering
    \begin{minipage}{\dimexpr\textwidth\relax}
    \includegraphics[
        width=0.9\textwidth,
        keepaspectratio
    ]{look_into_mirror.png}
    \end{minipage}
  }
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Contents}
  \Large
  \begin{itemize}
    \item Reflection
    \item Metaobjects and metadata
    \item Reflection APIs
    \item Examples
    \item Some use-cases
  \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Metaobject}
  \larger
  \begin{itemize}
    \item A {\em meta-level} representation of a {\em base-level} entity
      \begin{itemize}
      \smaller
        \item namespace, type, function, constructor, destructor, variable,
          constant, expression, \ldots
      \end{itemize}
    \item On the {\em meta-level\footnote{unlike the base-level}} all
      of the above are \say{reified}
      \begin{itemize}
      \smaller
        \item can be stored in variables, used as function arguments and
          return values,
        \item provide the ability to write reflection algorithm libraries,
        \item working at compile-time.
      \end{itemize}
    \item We say it \say{reflects} the {\em base-level} entity
  \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Metaobject}
  \framesubtitle{continued}
  \larger
  \begin{itemize}
    \item Provides access to {\em metadata} describing the reflected
      {\em base-level} entity
      \begin{itemize}
      \smaller
        \item type of a variable,
        \item data members of a \inlinecode{struct},
        \item constructors or member functions of a \inlinecode{class},
        \item base classes of a \inlinecode{class},
        \item return type of a function,
        \item parameters of a function,
        \item enumerators in an \inlinecode{enum} type,
        \item name of a namespace, type, function, data member, parameter, etc.
        \item address of a variable, data member or member function,
        \item specifiers like \inlinecode{virtual}, \inlinecode{constexpr},
          \inlinecode{static}, \inlinecode{noexcept}, \inlinecode{public},
          \inlinecode{protected}, \inlinecode{private}, etc.
        \item source location\footnote{except for built-ins},
        \item \ldots
      \end{itemize}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Metaobject}
  \framesubtitle{continued}
  \larger
  In a program a {\em metaobject} is a compile-time constant
    {\larger value} of a type satisfying the~following concept:
  \begin{lstlisting}[language=c++2x]
template <typename X>
concept metaobject = (*@{\em not-really-important-here}@*);
  \end{lstlisting}
  \vfill
  Can be used to constrain function arguments:
  \begin{lstlisting}[language=c++2x]
void foo((*@\listinghl{metaobject}@*) auto m) { /*...*/ }
  \end{lstlisting}
  or more generally in a \inlinecode{requires} clause,
  \begin{lstlisting}[language=c++2x]
void bar(auto m)
  requires((*@\listinghl{metaobject}@*)<decltype(m)>) {
    /*...*/
}
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Reflection}
  \larger
  \begin{itemize}
    \item The process of obtaining metadata or metaobjects providing metadata
      indirectly.
    \item Done through a~dedicated operator or~language expression:
    \item For example:
  \end{itemize}
  \begin{lstlisting}[language=c++2x]
const auto meta_int = (*@\listinghl{mirror}\footnote{\inlinecode{mirror} is a~placeholder
      for the~actual reflection expression}@*)(int);
static_assert(
  metaobject<decltype(meta_int)>);
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Reflection API}
  \larger
  \begin{itemize}
    \item Set of (compile-time) functions operating on {\em metaobjects}
    \item Several groups
    \begin{itemize}
      \item metaobject classification functions,
      \item primitive metadata extraction,
      \item metaobject sequence operations,
      \item general-purpose algorithms,
      \item predicates, comparators, transformation functions,
      \item syntax sugar, placeholder expressions,
      \item \ldots
    \end{itemize}
  \end{itemize}
\end{frame}
% - Design ---------------------------------------------------------------------
\section{API Design}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Reflection API}
  \framesubtitle{design considerations}
  \larger
  \begin{itemize}
    \item The general API design stuff
    \item Concise and clear syntax, functional-style
    \item Support for as many use-cases as possible
    \item Provide functions handling recurring patterns and use-cases
    \item Support composition of function calls into bigger custom algorithms
    \item Proper ADL\footnote{argument-dependent lookup}; should not require
      excessive name qualification
    \item Be similar to the STL and other commonly-used libraries\footnote{
        boost, \ldots}, where it makes sense.
  \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Hello, reflection!}
  \framesubtitle{the obligatory first example}
  \begin{lstlisting}[language=c++2x]
struct hello {};

int main() {
  hello world;

  std::cout << get_name((*@\listinghl{mirror}@*)(hello))
            << ", "
            << (*@\listinghl{get_name}@*)(mirror(world))
            << "!" << std::endl;

    return 0;
}
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Reflection API}
  \framesubtitle{metaobject classification}
  \begin{itemize}
    \item Indicate {\em \larger what} does a metaobject reflect
    \item Return \inlinecode{true} or \inlinecode{false}
    \item Are \inlinecode{consteval}
    \item \inlinecode{auto reflects_object(metaobject auto m) -> bool;}
    \item \footnotesize\inlinecode{auto reflects_\{object_sequence, named, alias, typed,
    scope, scope_member, enumerator, record_member, base, namespace, global_scope,
    type, enum, record, class, lambda, constant, variable, lambda_capture,
    function_parameter, callable, function, member_function,
    special_member_function, constructor, destructor, operator, conversion_operator,
    expression, parenthesized_expression, function_call_expression\}(metaobject auto m) -> bool;}
    \item \normalsize Typically used in \inlinecode{requires} clauses or
      in \inlinecode{if constexpr}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Reflection API}
  \framesubtitle{metadata retrieval functions}
  \begin{itemize}
    \item Return individual \say{atomic} pieces of metadata
    \item Some are applicable to all metaobjects
    \begin{itemize}
      \smaller
      \item \inlinecode{get_source_line}, \inlinecode{get_source_column},
        \inlinecode{reflects_same}, \ldots
    \end{itemize}
  \item Some only on metaobjects reflecting specific {\em base-level} entities
    \begin{itemize}
      \smaller
      \item where they make sense,
      \item \inlinecode{get_name}, \inlinecode{get_type}, \inlinecode{get_scope},
        \inlinecode{get_enumerators}, \ldots
    \end{itemize}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Reflection API}
  \framesubtitle{metadata retrieval functions}
  \larger
  \begin{itemize}
  \item Return one of these things:
    \begin{itemize}
      \smaller
      \item boolean values (\inlinecode{is_static}),
      \item integer values (\inlinecode{get_source_line}),
      \item other constant values\footnote{like enumerators} (\inlinecode{get_constant}),
      \item pointers or references\footnote{to values, data member, functions},
      \item strings\footnote{string views actually} (\inlinecode{get_source_file_name},
        \inlinecode{get_name}),
      \item types\footnote{or type identity} (\inlinecode{get_reflected_type},
      \item other metaobjects (\inlinecode{get_scope}, \inlinecode{get_data_members}).
    \end{itemize}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Reflection API}
  \framesubtitle{somewhere in logging\ldots}
  \begin{lstlisting}[language=c++2x,basicstyle=\footnotesize\ttfamily]
auto get_display_name(metaobject auto mo) -> string_view
  requires((*@\listinghl{reflects_named}@*)(mo));
  \end{lstlisting}
  \begin{lstlisting}[language=c++2x,basicstyle=\footnotesize\ttfamily]
void log_who_did_this(
  metaobject auto mo,
  ostream& log) {
  if constexpr((*@\listinghl{reflects_global_scope}@*)(mo)) {
    log << "it was the global scope!"
  } else if constexpr((*@\listinghl{reflects_named}@*)(mo)) {
    log << "it was " << get_display_name(mo);
  } else {
    log << "how the hell should I know?"
  }
}
  \end{lstlisting}
\end{frame}
% - Primitives -----------------------------------------------------------------
\section{Primitives}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Metadata getters}
  \framesubtitle{source location}
  \begin{lstlisting}[language=c++2x]
auto get_source_file_name(metaobject auto)
  -> string_view;

auto get_source_line(metaobject auto)
  -> unsigned long;
auto get_source_column(metaobject auto)
  -> unsigned long;
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Metadata getters}
  \framesubtitle{names}
  \begin{lstlisting}[language=c++2x]
auto get_name(metaobject auto mo)
  -> string_view
  requires(reflects_named(mo));
// "basic_string"

auto get_display_name(metaobject auto mo)
  -> string_view
  requires(reflects_named(mo));
// "string"

auto get_full_name(metaobject auto mo)
  -> string;
// "std::basic_string<char, ...>"
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Metadata getters}
  \framesubtitle{specifiers}
  \begin{lstlisting}[language=c++2x,basicstyle=\footnotesize\ttfamily]
auto is_constexpr(metaobject auto mo) -> bool
  requires(reflects_variable(mo) ||
           reflects_callable(mo));

auto is_noexcept(metaobject auto mo) -> bool
  requires(reflects_callable(mo));

auto is_explicit(metaobject auto mo) -> bool
  requires(reflects_constructor(mo) ||
           reflects_conversion_operator(mo));

auto is_static(metaobject auto mo) -> bool
  requires(reflects_variable(mo) ||
           reflects_member_function(mo));

auto is_virtual(metaobject auto mo) -> bool
  requires(reflects_base(mo) ||
           reflects_destructor(mo)) ||
           reflects_member_function(mo));
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Metadata getters}
  \framesubtitle{miscelaneous}
  \begin{lstlisting}[language=c++2x,basicstyle=\scriptsize\ttfamily]
auto uses_class_key(metaobject auto mo) -> bool
  requires(reflects_type(mo));

auto uses_default_copy_capture(metaobject auto mo) -> bool
  requires(reflects_lambda(mo));

auto is_explicitly_captured(metaobject auto mo) -> bool
  requires(reflects_lambda_capture(mo));

auto has_default_argument(metaobject auto mo) -> bool
  requires(reflects_function_parameter(mo));

auto has_lvalueref_qualifier(metaobject auto mo) -> bool
  requires(reflects_member_function(mo));

auto is_implicitly_declared(metaobject auto mo) -> bool
  requires(reflects_special_member_function(mo));

auto is_deleted(metaobject auto mo) -> bool
  requires(reflects_callable(mo));

auto is_move_constructor(metaobject auto mo) -> bool
  requires(reflects_constructor(mo));
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Metadata getters}
  \framesubtitle{values, references and pointers}
  \begin{lstlisting}[language=c++2x,basicstyle=\scriptsize\ttfamily]
auto get_constant(metaobject auto mo)
  requires(reflects_constant(mo));

auto get_value(metaobject auto mo) -> const auto&
  requires(reflects_variable(mo));
auto get_value(metaobject auto mo, auto& obj)-> const auto&
  requires(reflects_record_member(mo) &&
           reflects_variable(mo));

auto get_reference(metaobject auto mo) -> auto&
  requires(reflects_variable(mo));
auto get_reference(metaobject auto mo, auto& obj) -> auto&
  requires(reflects_record_member(mo) &&
           reflects_variable(mo));

auto get_pointer(metaobject auto mo) -> auto*
  requires(reflects_variable(mo) ||
           reflects_function(mo));
auto get_pointer(metaobject auto mo, auto& obj) -> auto*
  requires(reflects_record_member(mo) &&
           reflects_variable(mo));
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Metadata getters}
  \framesubtitle{invocation}
  \begin{lstlisting}[language=c++2x,basicstyle=\footnotesize\ttfamily]
auto invoke(metaobject auto mo, auto&&... args)
  requires(reflects_function(mo));

auto invoke(metaobject auto mo, auto&&... args)
  requires(reflects_member_function(mo) &&
           is_static(mo));

auto invoke(auto mo, auto& inst, auto&&... args)
  requires(reflects_member_function(mo) &&
           !is_static(mo));

auto invoke(metaobject auto mo, auto&&... args)
  requires(reflects_constructor(mo));

auto invoke_on(auto mo, auto& inst, auto&&... args)
  requires(reflects_member_function(mo));
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Metadata getters}
  \framesubtitle{metaobjects}
 \begin{lstlisting}[language=c++2x,basicstyle=\footnotesize\ttfamily]
auto get_scope(metaobject auto mo)
  requires(reflects_scoped(mo));

auto get_type(metaobject auto mo)
  requires(reflects_typed(mo));

auto get_underlying_type(metaobject auto mo)
  requires(reflects_enum(mo));

auto get_aliased(metaobject auto mo)
  requires(reflects_alias(mo));

auto get_class(metaobject auto mo)
  requires(reflects_base(mo));

auto get_subexpression(metaobject auto mo)
  requires(reflects_parenthesized_expression(mo));

// and more...
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Metadata getters}
  \framesubtitle{{\em base-level} types}
 \begin{lstlisting}[language=c++2x,basicstyle=\footnotesize\ttfamily]
template <metaobject MO>
using get_reflected_type_t = (*@\listinghl{unspecified}@*);

auto get_reflected_type(metaobject auto mo)
  -> type_identity<(*@\listinghl{unspecified}@*)>
  requires(reflects_type(mo));

template <typename T>
auto is_type(
  metaobject auto mo,
  type_identity<T> = {})
  -> bool requires(reflects_type(mo));

template <template <typename> class Trait>
auto has_type_trait(metaobject auto mo) 
  -> bool requires(reflects_type(mo));

  \end{lstlisting}
\end{frame}
% - Sequences ------------------------------------------------------------------
\section{Sequences}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Metaobject sequences}
  \larger
  \begin{itemize}
    \item Are (special kind of) metaobjects themselves
    \item Represent collections of other metaobjects
    \item Returned by many metaobject operations
    \begin{itemize}
      \smaller
      \item base classes,
      \item data members,
      \item member functions,
      \item constructors, destructors,
      \item enumerators,
      \item \ldots
    \end{itemize}
    \item Only unpacked on demand to improve performance
  \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Metaobject sequences}
  \framesubtitle{getting sequences}
  \begin{lstlisting}[language=c++2x,basicstyle=\small\ttfamily]
auto get_base_classes(metaobject auto mo)
  requires(reflects_class(mo));

auto get_captures(metaobject auto mo)
  requires(reflects_lambda(mo));

auto get_constructors(metaobject auto mo)
  requires(reflects_record(mo));

auto get_data_members(metaobject auto mo)
  requires(reflects_record(mo));

auto get_destructors(metaobject auto mo)
  requires(reflects_record(mo));
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Metaobject sequences}
  \framesubtitle{getting sequences}
  \begin{lstlisting}[language=c++2x,basicstyle=\small\ttfamily]
auto get_enumerators(metaobject auto mo)
  requires(reflects_enum(mo));

auto get_member_functions(metaobject auto mo)
  requires(reflects_record(mo));

auto get_member_types(metaobject auto mo)
  requires(reflects_record(mo));

auto get_operations(metaobject auto mo)
  requires(reflects_record(mo));

auto get_parameters(metaobject auto mo)
  requires(reflects_callable(mo));
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Metaobject sequences}
  \framesubtitle{basic operations}
  \larger
  \begin{itemize}
    \item Is something a sequence (\inlinecode{is_object_sequence})
    \item Is there anything in the sequence (\inlinecode{is_empty})
    \item How many elements are there (\inlinecode{get_size})
    \item Get the I-th element (\inlinecode{get_element<I>})
    \item Concatenate (\inlinecode{concat}).
  \end{itemize}
\end{frame}
% - Placeholders ---------------------------------------------------------------
\section{Placeholders}
% - Algorithms -----------------------------------------------------------------
\section{Algorithms}
% - Composition ----------------------------------------------------------------
\section{Compositions}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Are data members sorted by size?}
  \begin{columns}
    \begin{column}{.45\textwidth}
      \begin{lstlisting}[language=c++2x,basicstyle=\small\ttfamily]
struct foo {
    double d;
    int i;
    short s;
    char c;
};
      \end{lstlisting}
    \end{column}
    \begin{column}{.45\textwidth}
      \begin{lstlisting}[language=c++2x,basicstyle=\small\ttfamily]
struct bar {
    int i;
    float f;
    long l;
    bool b;
};
      \end{lstlisting}
    \end{column}
  \end{columns}
  \begin{lstlisting}[language=c++2x,basicstyle=\small\ttfamily]
const auto are_sorted_by_size = is_sorted(
  get_member_functions(_1),
  get_sizeof(_1) < get_sizeof(_2));

cout << are_sorted_by_size(mirror(foo))<< endl;
cout << are_sorted_by_size(mirror(bar))<< endl;
  \end{lstlisting}
  \begin{verbatim}
  1
  0
  \end{verbatim}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Are member functions sorted by name?}
  \begin{columns}
    \begin{column}{.65\textwidth}
      \begin{lstlisting}[language=c++2x,basicstyle=\footnotesize\ttfamily]
struct foo {
  int plus(int x) {
    return x;
  }
  int plus(int x, int y) {
    return x + y;
  }
  int plus(int x, int y, int z) {
    return x + y + z;
  }
  int minus(int x) {
    return -x;
  }
  int minus(int x, int y) {
    return x - y;
  }
};
      \end{lstlisting}
    \end{column}
    \begin{column}{.35\textwidth}
      \begin{lstlisting}[language=c++2x,basicstyle=\small\ttfamily]
struct bar {
  int a() {
    return 0;
  }
  int b() {
    return 1;
  }
  int c() {
    return 2;
  }
};
      \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Are member functions sorted by name?}
  \begin{lstlisting}[language=c++2x,basicstyle=\small\ttfamily]
const auto are_sorted_by_name = is_sorted(
  get_member_functions(_1),
  get_name(_1) < get_name(_2));

cout << are_sorted_by_name(mirror(foo))<< endl;
cout << are_sorted_by_name(mirror(bar))<< endl;
  \end{lstlisting}
  Output:
  \begin{verbatim}
  0
  1
  \end{verbatim}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Are enumerators consecutive?}
  \begin{columns}
    \begin{column}{.43\textwidth}
      \begin{lstlisting}[language=c++2x,basicstyle=\small\ttfamily]
enum class digits {
    zero = 0,
    one,
    two,
    three,
    four,
    five,
    six,
    seven,
    eight,
    nine
};
      \end{lstlisting}
    \end{column}
    \begin{column}{.47\textwidth}
      \begin{lstlisting}[language=c++2x,basicstyle=\small\ttfamily]
enum class po2s {
    one = 1,
    two = 2,
    four = 4,
    eight = 8,
    sixteen = 16,
    thirty_two = 32
};
      \end{lstlisting}
    \end{column}
  \end{columns}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Are enumerators consecutive?}
  \begin{lstlisting}[language=c++2x,basicstyle=\small\ttfamily]
const auto are_consecutive =
  is_sorted(get_enumerators(_1),
  [](metaobject auto l, metaobject auto r) {
      return int(get_constant(l)) ==
             int(get_constant(r)) - 1;
  });

cout << are_consecutive(mirror(digits))<< endl;
cout << are_consecutive(mirror(po2s)) << endl;
  \end{lstlisting}
  Output:
  \begin{verbatim}
  1
  0
  \end{verbatim}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Find enumerator with longest name}
  \begin{lstlisting}[language=c++2x,basicstyle=\footnotesize\ttfamily]
void print_enum(metaobject auto mo) {
    const auto find_enum_with_longest_name =
      find_ranking(
        get_enumerators(_1),
        get_size(get_name(_1)));

    const auto me = find_enum_with_longest_name(mo);

    cout << get_name(me)
         << ", length: "
         << get_name(me).size()
         << ", value: "
         << int(get_constant(me))
         << endl;
}
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Find enumerator with longest name}
  \begin{columns}
    \begin{column}{.45\textwidth}
      \begin{lstlisting}[language=c++2x,basicstyle=\scriptsize\ttfamily]
enum class weekday : int {
    monday = 1,
    tuesday,
    wednesday,
    thursday,
    friday,
    saturday,
    sunday
};
      \end{lstlisting}
    \end{column}
    \begin{column}{.45\textwidth}
      \begin{lstlisting}[language=c++2x,basicstyle=\tiny\ttfamily]
enum class month : int {
    january = 1,
    february,
    march,
    april,
    may,
    june,
    july,
    august,
    september,
    october,
    november,
    december
};
      \end{lstlisting}
    \end{column}
  \end{columns}
  \begin{lstlisting}[language=c++2x]
  print_enum(mirror(weekday));
  print_enum(mirror(month));
  \end{lstlisting}
  Output:
  \begin{verbatim}
  wednesday, length: 9, value: 3
  september, length: 9, value: 9
  \end{verbatim}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Does a class have overloaded functions?}
  \begin{lstlisting}[language=c++2x,basicstyle=\footnotesize\ttfamily]
auto has_overloaded_functions =
  [](metaobject auto mo) {
    const auto mfs = (*@\listinghl{get_member_functions}@*)(mo);
    return fold(
      mfs,
      [mfs](auto mf1) {
        return any_of(mfs, [mf1](auto mf2) {
          return !(*@\listinghl{reflects_same}@*)(mf1, mf2) &&
             (*@\listinghl{get_name}@*)(mf1) == (*@\listinghl{get_name}@*)(mf2);
        });
      },
      [](auto... b) { return (... || b); });
  };
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Does a class have overloaded functions?}
  \begin{columns}
    \begin{column}{.50\textwidth}
      \begin{lstlisting}[language=c++2x,basicstyle=\tiny\ttfamily]
struct foo {
  int plus(int x) {
    return x;
  }
  int plus(int x, int y) {
    return x + y;
  }
  int plus(int x, int y, int z) {
    return x + y + z;
  }
  int minus(int x) {
    return -x;
  }
  int minus(int x, int y) {
    return x - y;
  }
};
      \end{lstlisting}
    \end{column}
    \begin{column}{.40\textwidth}
      \begin{lstlisting}[language=c++2x,basicstyle=\scriptsize\ttfamily]
struct bar {
  int a() {
    return 0;
  }
  int b() {
    return 1;
  }
  int c() {
    return 2;
  }
};
      \end{lstlisting}
    \end{column}
  \end{columns}
  \begin{lstlisting}[language=c++2x,basicstyle=\footnotesize\ttfamily]
cout << has_overloaded_functions(mirror(foo))<< endl;
cout << has_overloaded_functions(mirror(bar))<< endl;
  \end{lstlisting}
  Output:
  \begin{verbatim}
  1
  0
  \end{verbatim}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{\say{Smart} concept definition}
  \framesubtitle{featuring CTRE!}
  \begin{lstlisting}[language=c++2x,basicstyle=\footnotesize\ttfamily]
template <typename T>
concept very_smart_integer(*@\footnote{don't try this at home}@*) = (*@\listinghl{ctre_match}@*)<
  "((signed|unsigned) )?"\
  "((long long|long|short)( int)?|int)"
>((*@\listinghl{get_name}@*)(remove_all_aliases(mirror(T))));

auto add(
  very_smart_integer auto l,
  very_smart_integer auto r) {
    return l + r;
}
  \end{lstlisting}
  \begin{lstlisting}[language=c++2x,basicstyle=\small\ttfamily]
cout << add(1U, 2U) << endl;
cout << add(short(3), short(4)) << endl;
cout << add(21, 21) << endl;
cout << add(400ULL, 20ULL) << endl;
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{MOAR \say{smart} concepts!}
  \begin{lstlisting}[language=c++2x,basicstyle=\small\ttfamily]
struct excellent {
    void foo() {}
    void bar() {}
    void baz() {}
};

template <typename T>
concept has_foo_and_such = any_of(
  get_member_functions(mirror(T)),
  ctre_match<"foo|bar|baz">(get_name(_1)));

void foonction(has_foo_and_such auto) {
    cout << "this is wonderful!" << endl;
}
  \end{lstlisting}
\end{frame}
% - Conclusion -----------------------------------------------------------------
\section{Conclusion}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Additional use-cases}
  \framesubtitle{details in other talks}
  \begin{itemize}
    \item Implementation of the {\em factory} pattern
    \item Auto-registering with script language bindings
    \item Serialization
    \item Generating UML diagrams from code
    \item Implementation of RPC\footnote{remote procedure calls}
    \item Generating DB system queries
    \item Fetching data from databases into C++ structures
    \item Parsing of command-line arguments
    \item Parsing of configuration files
    \item \ldots
  \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Where does this come from}
  \larger
  \begin{itemize}
    \item The {\em Mirror} library
    \begin{itemize}
      \item primitive and sequence operations,
      \item algorithms,
      \item placeholder expressions,
      \item examples and use-cases\footnote{including bigger ones},
      \item integration with other projects\footnote{CTRE, rapidjson, chaiscript,
        sqlite3, etc.},
      \item \ldots
    \end{itemize}
    \item On top of the reflection TS implementation in \inlinecode{clang}
    \item There is much more than what fits into a talk
    \item See the reference (links below)
  \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{Links, shameless plugs, etc.}
  \begin{itemize}
    \item {\em Reflection TS in \inlinecode{clang}} --
      \url{https://github.com/matus-chochlik/llvm-project}
    \item {\em The Mirror library repository} --
      \url{https://github.com/matus-chochlik/mirror}
    \item {\em The Mirror library reference (W.I.P.)} --
      \url{matus-chochlik.github.io/mirror/doxygen/}
  \end{itemize}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{That's all folks\dots}
  \centering
  \Huge
  Thanks for your attention.\\
  \Large
  Happy to answer any additional questions.
\end{frame}
% - Extras ---------------------------------------------------------------------
\section{Extras}
% ------------------------------------------------------------------------------
\begin{frame}
  \frametitle{There is more}
  \makebox[\linewidth][c]{
    \centering
    \begin{minipage}{\dimexpr\textwidth\relax}
    \includegraphics[
        width=0.9\textwidth,
        keepaspectratio
    ]{extras.png}
    \end{minipage}
  }
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Are enumerators bitfield bits?}
  \begin{lstlisting}[language=c++2x,basicstyle=\footnotesize\ttfamily]
const auto is_bitfield_enum =
  is_sorted(get_enumerators(_1), [](auto l, auto r) {
    if constexpr(has_type_trait<is_signed>(
      get_underlying_type(get_type(l)))) {
      return false;
    } else {
      auto to_underlying = [](auto e) {
        using U = underlying_type_t<decltype(e)>;
        return static_cast<U>(e);
      };
      return to_underlying(get_constant(l)) << 1U ==
             to_underlying(get_constant(r));
    }
  });
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
\begin{frame}[fragile]
  \frametitle{Does a structure have some padding?}
  \begin{lstlisting}[language=c++2x,basicstyle=\footnotesize\ttfamily]
template <typename... T>
auto sum_sizeofs(type_list<T...>) -> bool {
    return (0Z + ... + sizeof(T));
}

template <typename T>
auto has_padding() -> bool {
    return sizeof(T) >
           sum_sizeofs(extract_types(transform(
             filter(get_data_members(mirror(T)),
                    not_(is_static(_1))),
             get_type(_1))));
}
  \end{lstlisting}
\end{frame}
% ------------------------------------------------------------------------------
% ------------------------------------------------------------------------------
\end{document}
